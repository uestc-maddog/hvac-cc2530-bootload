###############################################################################
#
# IAR C/C++ Compiler V9.30.1.3056 for 8051                18/Feb/2016  11:01:33
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  near
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\HVAC
#        Project\hvac-cc2530-mesh\Projects\zstack\Utilities\BootLoad\CC2530\source\sb_main.c
#    Command line       =  
#        "D:\HVAC
#        Project\hvac-cc2530-mesh\Projects\zstack\Utilities\BootLoad\CC2530\source\sb_main.c"
#        -D HAL_SB_BOOT_CODE -D HAL_UART=TRUE -D HAL_UART_DMA=0 -D
#        HAL_UART_ISR=1 -D HAL_UART_ISR_RX_MAX=254 -lC "D:\HVAC
#        Project\hvac-cc2530-mesh\Projects\zstack\Utilities\BootLoad\CC2530\CC2530BL\List"
#        -lA "D:\HVAC
#        Project\hvac-cc2530-mesh\Projects\zstack\Utilities\BootLoad\CC2530\CC2530BL\List"
#        -o "D:\HVAC
#        Project\hvac-cc2530-mesh\Projects\zstack\Utilities\BootLoad\CC2530\CC2530BL\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=near --calling_convention=xdata_reentrant
#        --place_constants=data --nr_virtual_regs 16 -I "D:\HVAC
#        Project\hvac-cc2530-mesh\Projects\zstack\Utilities\BootLoad\CC2530\..\Source\"
#        -I "D:\HVAC
#        Project\hvac-cc2530-mesh\Projects\zstack\Utilities\BootLoad\CC2530\source\"
#        -I "D:\HVAC
#        Project\hvac-cc2530-mesh\Projects\zstack\Utilities\BootLoad\CC2530\..\..\..\..\..\Components\hal\include\"
#        -I "D:\HVAC
#        Project\hvac-cc2530-mesh\Projects\zstack\Utilities\BootLoad\CC2530\..\..\..\..\..\Components\hal\target\_COMMON\CC2530\"
#        -I "D:\HVAC
#        Project\hvac-cc2530-mesh\Projects\zstack\Utilities\BootLoad\CC2530\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -Ohz --require_prototypes
#    List file          =  
#        D:\HVAC
#        Project\hvac-cc2530-mesh\Projects\zstack\Utilities\BootLoad\CC2530\CC2530BL\List\sb_main.lst
#    Object file        =  
#        D:\HVAC
#        Project\hvac-cc2530-mesh\Projects\zstack\Utilities\BootLoad\CC2530\CC2530BL\Obj\sb_main.r51
#
###############################################################################

D:\HVAC Project\hvac-cc2530-mesh\Projects\zstack\Utilities\BootLoad\CC2530\source\sb_main.c
      1          /**************************************************************************************************
      2            Filename:       sb_main.c
      3            Revised:        $Date: 2013-11-19 09:36:42 -0800 (Tue, 19 Nov 2013) $
      4            Revision:       $Revision: 36147 $
      5          
      6            Description:    This module contains the main functionality of a Boot Loader for CC2530.
      7                            It is a minimal subset of functionality from ZMain.c, OnBoard.c and various
      8                            _hal_X.c modules for the CC2530EB target.
      9          
     10          
     11            Copyright 2009-2013 Texas Instruments Incorporated. All rights reserved.
     12          
     13            IMPORTANT: Your use of this Software is limited to those specific rights
     14            granted under the terms of a software license agreement between the user
     15            who downloaded the software, his/her employer (which must be your employer)
     16            and Texas Instruments Incorporated (the "License").  You may not use this
     17            Software unless you agree to abide by the terms of the License. The License
     18            limits your use, and you acknowledge, that the Software may not be modified,
     19            copied or distributed unless embedded on a Texas Instruments microcontroller
     20            or used solely and exclusively in conjunction with a Texas Instruments radio
     21            frequency transceiver, which is integrated into your product.  Other than for
     22            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     23            works of, modify, distribute, perform, display or sell this Software and/or
     24            its documentation for any purpose.
     25          
     26            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     27            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     28            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     29            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     30            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     31            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     32            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     33            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     34            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     35            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     36            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     37          
     38            Should you have any questions regarding your right to use this Software,
     39            contact Texas Instruments Incorporated at www.TI.com.
     40          **************************************************************************************************/
     41          
     42          /* ------------------------------------------------------------------------------------------------
     43           *                                          Includes
     44           * ------------------------------------------------------------------------------------------------
     45           */
     46          
     47          #include "hal_board_cfg.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x86
   \   unsigned char volatile __sfr U0CSR
   \                     U0CSR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x88
   \   union <unnamed> volatile __sfr _A_TCON
   \                     _A_TCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9d
   \   unsigned char volatile __sfr SLEEPSTA
   \                     SLEEPSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9e
   \   unsigned char volatile __sfr CLKCONSTA
   \                     CLKCONSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa0
   \   union <unnamed> volatile __sfr _A_P2
   \                     _A_P2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb6
   \   unsigned char volatile __sfr ADCCON3
   \                     ADCCON3:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbb
   \   unsigned char volatile __sfr ADCH
   \                     ADCH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbe
   \   unsigned char volatile __sfr SLEEPCMD
   \                     SLEEPCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc1
   \   unsigned char volatile __sfr U0DBUF
   \                     U0DBUF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc2
   \   unsigned char volatile __sfr U0BAUD
   \                     U0BAUD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc4
   \   unsigned char volatile __sfr U0UCR
   \                     U0UCR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc5
   \   unsigned char volatile __sfr U0GCR
   \                     U0GCR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc6
   \   unsigned char volatile __sfr CLKCONCMD
   \                     CLKCONCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc9
   \   unsigned char volatile __sfr WDCTL
   \                     WDCTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd4
   \   unsigned char volatile __sfr DMA0CFGL
   \                     DMA0CFGL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd5
   \   unsigned char volatile __sfr DMA0CFGH
   \                     DMA0CFGH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf1
   \   unsigned char volatile __sfr PERCFG
   \                     PERCFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf2
   \   unsigned char volatile __sfr ADCCFG
   \                     ADCCFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1
     48          #include "hal_adc.h"
     49          #include "hal_dma.h"
     50          #include "hal_flash.h"
     51          #include "hal_types.h"
     52          #include "sb_exec.h"
     53          #include "sb_main.h"
     54          
     55          /* ------------------------------------------------------------------------------------------------
     56           *                                          Constants
     57           * ------------------------------------------------------------------------------------------------
     58           */
     59          
     60          /* Delay jump to valid RC code, waiting for a force boot or force run indication via the
     61           * physical transport or button press indication. Set to zero to jump immediately, this
     62           * necessitates the RC to invalidate checksum/shadow to force boot mode.
     63           */
     64          #if !defined SB_UART_DELAY
     65          #define SB_UART_DELAY  0x260000  // About 1 minute.
     66          #endif
     67          
     68          /* ------------------------------------------------------------------------------------------------
     69           *                                           Macros
     70           * ------------------------------------------------------------------------------------------------
     71           */
     72          
     73          #if HAL_KEY
     74          #define SB1_PRESS  (P0_1 != 0)
     75          #define SB2_PRESS  (P2_0 != 0)
     76          #else
     77          #define SB1_PRESS   0
     78          #define SB2_PRESS   0
     79          #endif
     80          
     81          #if HAL_LED
     82          #define SB_INIT_LEDS() st (  \
     83            HAL_TURN_OFF_LED1();  \
     84            LED1_DDR |= LED1_BV;  \
     85            HAL_TURN_OFF_LED2();  \
     86            LED2_DDR |= LED2_BV;  \
     87          )
     88          #define SB_TURN_OFF_LED1()  HAL_TURN_OFF_LED1()
     89          #define SB_TURN_ON_LED1()   HAL_TURN_ON_LED1()
     90          #define SB_TOGGLE_LED1()    HAL_TOGGLE_LED1()
     91          #define SB_TURN_OFF_LED2()  HAL_TURN_OFF_LED2()
     92          #define SB_TURN_ON_LED2()   HAL_TURN_ON_LED2()
     93          #define SB_TOGGLE_LED2()    HAL_TOGGLE_LED2()
     94          #else
     95          #define SB_TURN_OFF_LED1()
     96          #define SB_TURN_ON_LED1()
     97          #define SB_TOGGLE_LED1()
     98          #define SB_TURN_OFF_LED2()
     99          #define SB_TURN_ON_LED2()
    100          #define SB_TOGGLE_LED2()
    101          #endif
    102          
    103          #if !defined ResetWasWatchDog
    104          #define ResetWasWatchDog ((SLEEPSTA & 0x18) == 0x10)
    105          #endif
    106          
    107          /* ------------------------------------------------------------------------------------------------
    108           *                                       Global Variables
    109           * ------------------------------------------------------------------------------------------------
    110           */
    111          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    112          halDMADesc_t dmaCh0;
   \                     dmaCh0:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    113          
    114          /* ------------------------------------------------------------------------------------------------
    115           *                                       Local Functions
    116           * ------------------------------------------------------------------------------------------------
    117           */
    118          
    119          static void sblExec(void);
    120          static void sblInit(void);
    121          static void sblJump(void);
    122          static void sblWait(void);
    123          static void vddWait(uint8 vdd);
    124          
    125          #include "_hal_uart_isr.c"

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \   static uartISRCfg_t isrCfg
   \                     isrCfg:
   \   000000                DS 517
   \   000205                REQUIRE __INIT_XDATA_Z

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   __near_func __xdata_reentrant uint16 HalUARTReadISR(uint8 *, uint16)
   \                     HalUARTReadISR:
   \   000000   74F8         MOV     A,#-0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 0
   \   000005   7800         MOV     R0,#0x0
   \   000007   7900         MOV     R1,#0x0
   \   000009   8027         SJMP    ??HalUARTReadISR_0
   \                     ??HalUARTReadISR_1:
   \   00000B   74..         MOV     A,#isrCfg & 0xff
   \   00000D   2E           ADD     A,R6
   \   00000E   F582         MOV     DPL,A
   \   000010   E4           CLR     A
   \   000011   34..         ADDC    A,#(isrCfg >> 8) & 0xff
   \   000013   F583         MOV     DPH,A
   \   000015   E0           MOVX    A,@DPTR
   \   000016   8A82         MOV     DPL,R2
   \   000018   8B83         MOV     DPH,R3
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   90....       MOV     DPTR,#isrCfg + 254
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   04           INC     A
   \   000020   12....       LCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_0:
   \   000023   C3           CLR     C
   \   000024   94FE         SUBB    A,#-0x2
   \   000026   4005         JC      ??HalUARTReadISR_2
   \   000028   90....       MOV     DPTR,#isrCfg + 254
   \   00002B   E4           CLR     A
   \   00002C   F0           MOVX    @DPTR,A
   \                     ??HalUARTReadISR_2:
   \   00002D   08           INC     R0
   \   00002E   E8           MOV     A,R0
   \   00002F   7001         JNZ     ??HalUARTReadISR_0
   \   000031   09           INC     R1
   \                     ??HalUARTReadISR_0:
   \   000032   90....       MOV     DPTR,#isrCfg + 254
   \   000035   E0           MOVX    A,@DPTR
   \   000036   FE           MOV     R6,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   6E           XRL     A,R6
   \   00003A   6007         JZ      ??HalUARTReadISR_3
   \   00003C   C3           CLR     C
   \   00003D   E8           MOV     A,R0
   \   00003E   9C           SUBB    A,R4
   \   00003F   E9           MOV     A,R1
   \   000040   9D           SUBB    A,R5
   \   000041   40C8         JC      ??HalUARTReadISR_1
   \                     ??HalUARTReadISR_3:
   \   000043   E8           MOV     A,R0
   \   000044   FA           MOV     R2,A
   \   000045   E9           MOV     A,R1
   \   000046   FB           MOV     R3,A
   \   000047   7F01         MOV     R7,#0x1
   \   000049   02....       LJMP    ?FUNC_LEAVE_XDATA

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006   AA82         MOV     R2,DPL
   \   000008   AB83         MOV     R3,DPH
   \   00000A   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   __near_func __xdata_reentrant uint16 HalUARTWriteISR(uint8 *, uint16)
   \                     HalUARTWriteISR:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   90....       MOV     DPTR,#isrCfg + 512
   \   000008   E0           MOVX    A,@DPTR
   \   000009   F5..         MOV     ?V1,A
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F5..         MOV     ?V0,A
   \   00000F   F8           MOV     R0,A
   \   000010   E5..         MOV     A,?V1
   \   000012   C3           CLR     C
   \   000013   98           SUBB    A,R0
   \   000014   F8           MOV     R0,A
   \   000015   95E0         SUBB    A,0xE0 /* A   */
   \   000017   F9           MOV     R1,A
   \   000018   E5..         MOV     A,?V0
   \   00001A   C3           CLR     C
   \   00001B   95..         SUBB    A,?V1
   \   00001D   E8           MOV     A,R0
   \   00001E   500B         JNC     ??HalUARTWriteISR_0
   \   000020   12....       LCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_2:
   \   000023   7011         JNZ     ??HalUARTWriteISR_1
   \                     ??HalUARTWriteISR_2:
   \   000025   7800         MOV     R0,#0x0
   \   000027   7900         MOV     R1,#0x0
   \   000029   801B         SJMP    ??HalUARTWriteISR_3
   \                     ??HalUARTWriteISR_0:
   \   00002B   24FD         ADD     A,#-0x3
   \   00002D   5001         JNC     ??HalUARTWriteISR_4
   \   00002F   09           INC     R1
   \                     ??HalUARTWriteISR_4:
   \   000030   C3           CLR     C
   \   000031   9C           SUBB    A,R4
   \   000032   E9           MOV     A,R1
   \   000033   9D           SUBB    A,R5
   \   000034   50EF         JNC     ??HalUARTWriteISR_2
   \                     ??HalUARTWriteISR_1:
   \   000036   7A00         MOV     R2,#0x0
   \   000038   7B00         MOV     R3,#0x0
   \   00003A   8041         SJMP    ??HalUARTWriteISR_5
   \                     ??HalUARTWriteISR_6:
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   04           INC     A
   \                     ??HalUARTWriteISR_7:
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   D2E9         SETB    0xe8.1
   \   000041   08           INC     R0
   \   000042   E8           MOV     A,R0
   \   000043   7001         JNZ     ??HalUARTWriteISR_3
   \   000045   09           INC     R1
   \                     ??HalUARTWriteISR_3:
   \   000046   C3           CLR     C
   \   000047   E8           MOV     A,R0
   \   000048   9C           SUBB    A,R4
   \   000049   E9           MOV     A,R1
   \   00004A   9D           SUBB    A,R5
   \   00004B   502C         JNC     ??HalUARTWriteISR_8
   \   00004D   8A82         MOV     DPL,R2
   \   00004F   8B83         MOV     DPH,R3
   \   000051   E0           MOVX    A,@DPTR
   \   000052   C0E0         PUSH    A
   \   000054   90....       MOV     DPTR,#isrCfg + 513
   \   000057   E0           MOVX    A,@DPTR
   \   000058   FE           MOV     R6,A
   \   000059   74..         MOV     A,#(isrCfg + 2) & 0xff
   \   00005B   2E           ADD     A,R6
   \   00005C   F582         MOV     DPL,A
   \   00005E   E4           CLR     A
   \   00005F   34..         ADDC    A,#((isrCfg + 258) >> 8) & 0xff
   \   000061   F583         MOV     DPH,A
   \   000063   D0E0         POP     A
   \   000065   12....       LCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_1:
   \   000068   90....       MOV     DPTR,#isrCfg + 514
   \   00006B   E4           CLR     A
   \   00006C   F0           MOVX    @DPTR,A
   \   00006D   90....       MOV     DPTR,#isrCfg + 513
   \   000070   E0           MOVX    A,@DPTR
   \   000071   C3           CLR     C
   \   000072   94FD         SUBB    A,#-0x3
   \   000074   40C6         JC      ??HalUARTWriteISR_6
   \   000076   E4           CLR     A
   \   000077   80C5         SJMP    ??HalUARTWriteISR_7
   \                     ??HalUARTWriteISR_8:
   \   000079   E8           MOV     A,R0
   \   00007A   FA           MOV     R2,A
   \   00007B   E9           MOV     A,R1
   \   00007C   FB           MOV     R3,A
   \                     ??HalUARTWriteISR_5:
   \   00007D   7F02         MOV     R7,#0x2
   \   00007F   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   000082                REQUIRE _A_IRCON2

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   24FF         ADD     A,#-0x1
   \   000002   18           DEC     R0
   \   000003   E9           MOV     A,R1
   \   000004   34FF         ADDC    A,#-0x1
   \   000006   F9           MOV     R1,A
   \   000007   E8           MOV     A,R0
   \   000008   49           ORL     A,R1
   \   000009   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   static __near_func __xdata_reentrant void HalUARTPollISR(void)
   \                     HalUARTPollISR:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   8025         SJMP    ??HalUARTPollISR_0
   \                     ??HalUARTPollISR_1:
   \   000006   E5C1         MOV     A,0xc1+0x0
   \   000008   C28B         CLR     0x88.3
   \   00000A   C0E0         PUSH    A
   \   00000C   90....       MOV     DPTR,#isrCfg + 255
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F8           MOV     R0,A
   \   000011   74..         MOV     A,#isrCfg & 0xff
   \   000013   28           ADD     A,R0
   \   000014   F582         MOV     DPL,A
   \   000016   E4           CLR     A
   \   000017   34..         ADDC    A,#(isrCfg >> 8) & 0xff
   \   000019   F583         MOV     DPH,A
   \   00001B   D0E0         POP     A
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   90....       MOV     DPTR,#isrCfg + 255
   \   000021   E0           MOVX    A,@DPTR
   \   000022   04           INC     A
   \   000023   F0           MOVX    @DPTR,A
   \   000024   C3           CLR     C
   \   000025   94FE         SUBB    A,#-0x2
   \   000027   4002         JC      ??HalUARTPollISR_0
   \   000029   E4           CLR     A
   \   00002A   F0           MOVX    @DPTR,A
   \                     ??HalUARTPollISR_0:
   \   00002B   A28B         MOV     C,0x88.3
   \   00002D   40D7         JC      ??HalUARTPollISR_1
   \                     ??HalUARTPollISR_2:
   \   00002F   A2E9         MOV     C,0xe8.1
   \   000031   5028         JNC     ??HalUARTPollISR_3
   \   000033   C2E9         CLR     0xe8.1
   \   000035   90....       MOV     DPTR,#isrCfg + 512
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F8           MOV     R0,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   68           XRL     A,R0
   \   00003D   60F0         JZ      ??HalUARTPollISR_2
   \   00003F   74..         MOV     A,#(isrCfg + 2) & 0xff
   \   000041   28           ADD     A,R0
   \   000042   F582         MOV     DPL,A
   \   000044   E4           CLR     A
   \   000045   34..         ADDC    A,#((isrCfg + 258) >> 8) & 0xff
   \   000047   F583         MOV     DPH,A
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   F5C1         MOV     0xc1,A
   \   00004C   90....       MOV     DPTR,#isrCfg + 512
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   04           INC     A
   \   000051   F0           MOVX    @DPTR,A
   \   000052   C3           CLR     C
   \   000053   94FE         SUBB    A,#-0x2
   \   000055   40D8         JC      ??HalUARTPollISR_2
   \   000057   E4           CLR     A
   \   000058   F0           MOVX    @DPTR,A
   \   000059   80D4         SJMP    ??HalUARTPollISR_2
   \                     ??HalUARTPollISR_3:
   \   00005B                REQUIRE ?Subroutine0
   \   00005B                REQUIRE _A_TCON
   \   00005B                REQUIRE _A_IRCON2
   \   00005B                REQUIRE U0DBUF
   \   00005B                ; // Fall through to label ?Subroutine0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   22           RET
    126          
    127          /**************************************************************************************************
    128           * @fn          main
    129           *
    130           * @brief       C-code main functionality.
    131           *
    132           * input parameters
    133           *
    134           * None.
    135           *
    136           * output parameters
    137           *
    138           * None.
    139           *
    140           * @return      None.
    141           **************************************************************************************************
    142           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    143          void main(void)
   \                     main:
    144          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                ; Auto size: 1
   \   000000   74FF         MOV     A,#-0x1
   \   000002   12....       LCALL   ?ALLOC_XSTACK8
    145            vddWait(VDD_MIN_RUN);
   \   000005                ; Setup parameters for call to function vddWait
   \   000005   794A         MOV     R1,#0x4a
   \   000007   12....       LCALL   vddWait
    146            HAL_BOARD_INIT();
   \   00000A   53BEFB       ANL     0xbe,#0xfb
   \                     ??main_0:
   \   00000D   E59D         MOV     A,0x9d
   \   00000F   A2E6         MOV     C,0xE0 /* A   */.6
   \   000011   50FA         JNC     ??main_0
   \   000013   00           NOP
   \   000014   78F8         MOV     R0,#-0x8
   \   000016   7901         MOV     R1,#0x1
   \                     ??main_1:
   \   000018   00           NOP
   \   000019   E8           MOV     A,R0
   \   00001A   12....       LCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_3:
   \   00001D   70F9         JNZ     ??main_1
   \   00001F   75C600       MOV     0xc6,#0x0
   \                     ??main_2:
   \   000022   E59E         MOV     A,0x9e
   \   000024   70FC         JNZ     ??main_2
   \   000026   43BE04       ORL     0xbe,#0x4
   \   000029   906270       MOV     DPTR,#0x6270
   \   00002C   7408         MOV     A,#0x8
   \   00002E   F0           MOVX    @DPTR,A
   \   00002F   12....       LCALL   ?Subroutine3
   \                     ??CrossCallReturnLabel_4:
   \   000032   C294         CLR     0x90.4
   \   000034   43FE10       ORL     0xfe,#0x10
   \   000037   438F01       ORL     0x8f,#0x1
    147          
    148            // make sure the DMA channel is selected before we attempt to
    149            // to write anything to flash.
    150            sblInit();
   \   00003A                ; Setup parameters for call to function sblInit
   \   00003A   12....       LCALL   sblInit
    151            
    152            if (sbImgValid())
   \   00003D                ; Setup parameters for call to function sbImgValid
   \   00003D   12....       LCALL   sbImgValid
   \   000040   E9           MOV     A,R1
   \   000041   7003         JNZ     $+5
   \   000043   02....       LJMP    ??main_3
    153            {
    154              if ((SB_UART_DELAY == 0) || ResetWasWatchDog)
   \   000046   E59D         MOV     A,0x9d
   \   000048   5418         ANL     A,#0x18
   \   00004A   6410         XRL     A,#0x10
   \   00004C   7003         JNZ     ??main_4
    155              {
    156                sblJump();
   \   00004E                ; Setup parameters for call to function sblJump
   \   00004E   12....       LCALL   sblJump
    157              }
    158          
    159              sblWait();
   \                     ??main_4:
   \   000051   75..00       MOV     ?V4,#0x0
   \   000054   75..00       MOV     ?V5,#0x0
   \   000057   75..26       MOV     ?V6,#0x26
   \   00005A   75..00       MOV     ?V7,#0x0
   \   00005D   8004         SJMP    ??main_5
   \                     ??main_6:
   \   00005F   C291         CLR     0x90.1
   \   000061   D290         SETB    0x90.0
   \                     ??main_5:
   \   000063                ; Setup parameters for call to function HalUARTPollISR
   \   000063   12....       LCALL   HalUARTPollISR
   \   000066                ; Setup parameters for call to function HalUARTReadISR
   \   000066   7C01         MOV     R4,#0x1
   \   000068   7D00         MOV     R5,#0x0
   \   00006A   AA..         MOV     R2,?XSP + 0
   \   00006C   AB..         MOV     R3,?XSP + 1
   \   00006E   12....       LCALL   HalUARTReadISR
   \   000071   8B..         MOV     ?V1,R3
   \   000073   EA           MOV     A,R2
   \   000074   45..         ORL     A,?V1
   \   000076   601C         JZ      ??main_7
   \   000078   85..82       MOV     DPL,?XSP + 0
   \   00007B   85..83       MOV     DPH,?XSP + 1
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   6410         XRL     A,#0x10
   \   000081   6049         JZ      ??main_8
   \   000083   E0           MOVX    A,@DPTR
   \   000084   64EF         XRL     A,#0xef
   \   000086   700C         JNZ     ??main_7
   \   000088   75..00       MOV     ?V4,#0x0
   \   00008B   75..00       MOV     ?V5,#0x0
   \   00008E   75..00       MOV     ?V6,#0x0
   \   000091   75..00       MOV     ?V7,#0x0
   \                     ??main_7:
   \   000094   A281         MOV     C,0x80.1
   \   000096   4034         JC      ??main_8
   \   000098   A2A0         MOV     C,0xa0.0
   \   00009A   401E         JC      ??main_9
   \   00009C   85....       MOV     ?V0,?V4
   \   00009F   85....       MOV     ?V1,?V5
   \   0000A2   85....       MOV     ?V2,?V6
   \   0000A5   85....       MOV     ?V3,?V7
   \   0000A8   90....       MOV     DPTR,#__Constant_ffffffff
   \   0000AB   78..         MOV     R0,#?V4
   \   0000AD   12....       LCALL   ?L_ADD_X
   \   0000B0   E5..         MOV     A,?V0
   \   0000B2   45..         ORL     A,?V1
   \   0000B4   45..         ORL     A,?V2
   \   0000B6   45..         ORL     A,?V3
   \   0000B8   7003         JNZ     ??main_10
   \                     ??main_9:
   \   0000BA                ; Setup parameters for call to function sblJump
   \   0000BA   12....       LCALL   sblJump
   \                     ??main_10:
   \   0000BD   85....       MOV     ?V1,?V5
   \   0000C0   E5..         MOV     A,?V1
   \   0000C2   5420         ANL     A,#0x20
   \   0000C4   7099         JNZ     ??main_6
   \   0000C6   C290         CLR     0x90.0
   \   0000C8   D291         SETB    0x90.1
   \   0000CA   8097         SJMP    ??main_5
   \                     ??main_8:
   \   0000CC   C290         CLR     0x90.0
   \   0000CE   C291         CLR     0x90.1
    160            }
    161          
    162            vddWait(VDD_MIN_NV);
   \                     ??main_3:
   \   0000D0                ; Setup parameters for call to function vddWait
   \   0000D0   794E         MOV     R1,#0x4e
   \   0000D2   12....       LCALL   vddWait
    163            sblExec();
   \   0000D5   75..00       MOV     ?V4,#0x0
   \   0000D8   75..00       MOV     ?V5,#0x0
   \   0000DB   75..00       MOV     ?V6,#0x0
   \   0000DE   75..00       MOV     ?V7,#0x0
   \   0000E1   8028         SJMP    ??main_11
   \                     ??main_12:
   \   0000E3   D290         SETB    0x90.0
   \   0000E5   D291         SETB    0x90.1
   \   0000E7   75..00       MOV     ?V4,#0x0
   \   0000EA   75..00       MOV     ?V5,#0x0
   \   0000ED   75..00       MOV     ?V6,#0x0
   \   0000F0   75..00       MOV     ?V7,#0x0
   \                     ??main_13:
   \   0000F3                ; Setup parameters for call to function HalUARTPollISR
   \   0000F3   12....       LCALL   HalUARTPollISR
   \   0000F6   90....       MOV     DPTR,#__Constant_1
   \   0000F9   78..         MOV     R0,#?V4
   \   0000FB   12....       LCALL   ?L_ADD_X
   \   0000FE   90....       MOV     DPTR,#__Constant_40000
   \   000101   78..         MOV     R0,#?V4
   \   000103   12....       LCALL   ?UL_GE_X
   \   000106   50EB         JNC     ??main_13
   \   000108                ; Setup parameters for call to function sblJump
   \   000108   12....       LCALL   sblJump
   \                     ??main_11:
   \   00010B                ; Setup parameters for call to function HalUARTPollISR
   \   00010B   12....       LCALL   HalUARTPollISR
   \   00010E                ; Setup parameters for call to function sbExec
   \   00010E   12....       LCALL   sbExec
   \   000111   E9           MOV     A,R1
   \   000112   6006         JZ      ??main_14
   \   000114                ; Setup parameters for call to function sbImgValid
   \   000114   12....       LCALL   sbImgValid
   \   000117   E9           MOV     A,R1
   \   000118   70C9         JNZ     ??main_12
   \                     ??main_14:
   \   00011A   85....       MOV     ?V1,?V5
   \   00011D   90....       MOV     DPTR,#__Constant_1
   \   000120   78..         MOV     R0,#?V4
   \   000122   12....       LCALL   ?L_ADD_X
   \   000125   E5..         MOV     A,?V1
   \   000127   5440         ANL     A,#0x40
   \   000129   60E0         JZ      ??main_11
   \   00012B   A290         MOV     C,0x90.0
   \   00012D   5004         JNC     ??main_15
   \   00012F   C290         CLR     0x90.0
   \   000131   80D8         SJMP    ??main_11
   \                     ??main_15:
   \   000133   D290         SETB    0x90.0
   \   000135   80D4         SJMP    ??main_11
   \   000137                REQUIRE SLEEPCMD
   \   000137                REQUIRE SLEEPSTA
   \   000137                REQUIRE CLKCONCMD
   \   000137                REQUIRE CLKCONSTA
   \   000137                REQUIRE _A_P1
   \   000137                REQUIRE P1DIR
   \   000137                REQUIRE P0INP
   \   000137                REQUIRE _A_IEN0
   \   000137                REQUIRE WDCTL
   \   000137                REQUIRE _A_P0
   \   000137                REQUIRE _A_P2
    164            HAL_SYSTEM_RESET();
    165          }

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   C290         CLR     0x90.0
   \   000002   43FE01       ORL     0xfe,#0x1
   \   000005   C291         CLR     0x90.1
   \   000007   43FE02       ORL     0xfe,#0x2
   \   00000A   22           RET
    166          
    167          /**************************************************************************************************
    168           * @fn          sblExec
    169           *
    170           * @brief       Infinite SBL execute loop that jumps upon receiving a code enable.
    171           *
    172           * input parameters
    173           *
    174           * None.
    175           *
    176           * output parameters
    177           *
    178           * None.
    179           *
    180           * @return      None.
    181           **************************************************************************************************
    182           */
    183          static void sblExec(void)
    184          {
    185            uint32 dlyCnt = 0;
    186          
    187            while (1)
    188            {
    189              HalUARTPollISR();
    190          
    191              if (sbExec() && sbImgValid())
    192              {
    193                SB_TURN_ON_LED1();
    194                SB_TURN_ON_LED2();
    195                // Delay to allow the SB_ENABLE_CMD response to be flushed.
    196                for (dlyCnt = 0; dlyCnt < 0x40000; dlyCnt++)
    197                {
    198                  HalUARTPollISR();
    199                }
    200          
    201                sblJump();
    202              }
    203              else if (dlyCnt++ & 0x4000)
    204              {
    205                SB_TOGGLE_LED1();
    206              }
    207            }
    208          }
    209          
    210          /**************************************************************************************************
    211           * @fn          sblInit
    212           *
    213           * @brief       SBL initialization.
    214           *
    215           * input parameters
    216           *
    217           * None.
    218           *
    219           * output parameters
    220           *
    221           * None.
    222           *
    223           * @return      None.
    224           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    225          static void sblInit(void)
   \                     sblInit:
    226          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    227            halUARTCfg_t uartConfig;
    228            /* This is in place of calling HalDmaInit() which would require init of the other 4 DMA
    229             * descriptors in addition to just Channel 0.
    230             */
    231            HAL_DMA_SET_ADDR_DESC0(&dmaCh0);
   \   000004   74..         MOV     A,#(dmaCh0 >> 8) & 0xff
   \   000006   F5D5         MOV     0xd5,A
   \   000008   75D4..       MOV     0xd4,#dmaCh0 & 0xff
    232          
    233            HalUARTInitISR();
   \   00000B   53FF3F       ANL     0xff,#0x3f
   \   00000E   85FFFF       MOV     0xff,0xff
   \   000011   53F1FE       ANL     0xf1,#0xfe
   \   000014   43F30C       ORL     0xf3,#0xc
   \   000017   53F2F3       ANL     0xf2,#0xf3
   \   00001A   758680       MOV     0x86,#-0x80
   \   00001D   75C480       MOV     0xc4,#-0x80
    234            uartConfig.configured           = TRUE;
    235            uartConfig.baudRate             = HAL_UART_BR_115200;
    236            uartConfig.flowControl          = FALSE;
    237            uartConfig.flowControlThreshold = 0;  // CC2530 by #define - see hal_board_cfg.h
    238            uartConfig.rx.maxBufSize        = 0;  // CC2530 by #define - see hal_board_cfg.h
    239            uartConfig.tx.maxBufSize        = 0;  // CC2530 by #define - see hal_board_cfg.h
    240            uartConfig.idleTimeout          = 0;  // CC2530 by #define - see hal_board_cfg.h
    241            uartConfig.intEnable            = TRUE;
    242            uartConfig.callBackFunc         = NULL;
    243            HalUARTOpenISR(&uartConfig);
   \   000020   90....       MOV     DPTR,#isrCfg + 515
   \   000023   E4           CLR     A
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   F0           MOVX    @DPTR,A
   \   000027   75C2D8       MOV     0xc2,#-0x28
   \   00002A   75C50B       MOV     0xc5,#0xb
   \   00002D   75C402       MOV     0xc4,#0x2
   \   000030   438640       ORL     0x86,#0x40
    244          
    245            SB_INIT_LEDS();
   \   000033   12....       LCALL   ?Subroutine3
    246          }
   \                     ??CrossCallReturnLabel_5:
   \   000036   02....       LJMP    ?Subroutine0
   \   000039                REQUIRE DMA0CFGH
   \   000039                REQUIRE DMA0CFGL
   \   000039                REQUIRE _A_P1
   \   000039                REQUIRE P1DIR
   \   000039                REQUIRE P2DIR
   \   000039                REQUIRE PERCFG
   \   000039                REQUIRE P0SEL
   \   000039                REQUIRE ADCCFG
   \   000039                REQUIRE U0CSR
   \   000039                REQUIRE U0UCR
   \   000039                REQUIRE U0BAUD
   \   000039                REQUIRE U0GCR
    247          
    248          /**************************************************************************************************
    249           * @fn          sblJump
    250           *
    251           * @brief       Execute a simple long jump from non-banked SBL code to non-banked RC code space.
    252           *
    253           * input parameters
    254           *
    255           * None.
    256           *
    257           * output parameters
    258           *
    259           * None.
    260           *
    261           * @return      None.
    262           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    263          static void sblJump(void)
   \                     sblJump:
    264          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    265            SB_TURN_ON_LED1();
   \   000000   D290         SETB    0x90.0
    266            SB_TURN_ON_LED2();
   \   000002   D291         SETB    0x90.1
    267            while (SB1_PRESS || SB2_PRESS);
   \                     ??sblJump_0:
   \   000004   A281         MOV     C,0x80.1
   \   000006   40FC         JC      ??sblJump_0
   \   000008   A2A0         MOV     C,0xa0.0
   \   00000A   40F8         JC      ??sblJump_0
    268            SB_TURN_OFF_LED1();
   \   00000C   C290         CLR     0x90.0
    269            SB_TURN_OFF_LED2();
   \   00000E   C291         CLR     0x90.1
    270            asm("LJMP 0x2000\n");  // Immediate jump to run-code.
   \   000010   022000       LJMP 0x2000
    271            HAL_SYSTEM_RESET();
   \   000013   C2AF         CLR     0xa8.7
   \   000015   75C9AB       MOV     0xc9,#-0x55
   \   000018   75C95B       MOV     0xc9,#0x5b
   \                     ??sblJump_1:
   \   00001B   80FE         SJMP    ??sblJump_1
   \   00001D                REQUIRE _A_P1
   \   00001D                REQUIRE _A_P0
   \   00001D                REQUIRE _A_P2
   \   00001D                REQUIRE _A_IEN0
   \   00001D                REQUIRE WDCTL
    272          }
    273          
    274          /**************************************************************************************************
    275           * @fn          sblWait
    276           *
    277           * @brief       A timed-out wait loop that exits early upon receiving a force code/sbl byte.
    278           *
    279           * input parameters
    280           *
    281           * None.
    282           *
    283           * output parameters
    284           *
    285           * None.
    286           *
    287           * @return      None.
    288           **************************************************************************************************
    289           */
    290          static void sblWait(void)
    291          {
    292            uint32 dlyCnt = SB_UART_DELAY;
    293          
    294            while (1)
    295            {
    296              uint8 ch;
    297          
    298              HalUARTPollISR();
    299              if (HalUARTReadISR(&ch, 1))
    300              {
    301                if (ch == SB_FORCE_BOOT)
    302                {
    303                  break;
    304                }
    305                else if (ch == SB_FORCE_RUN)
    306                {
    307                  dlyCnt = 0;
    308                }
    309              }
    310          
    311              if (SB1_PRESS)
    312              {
    313                break;
    314              }
    315          
    316              if (SB2_PRESS || (dlyCnt-- == 0))
    317              {
    318                sblJump();
    319              }
    320          
    321              // RR-xing LED display while waiting.
    322              if (dlyCnt & 0x2000)
    323              {
    324                SB_TURN_OFF_LED2();
    325                SB_TURN_ON_LED1();
    326              }
    327              else
    328              {
    329                SB_TURN_OFF_LED1();
    330                SB_TURN_ON_LED2();
    331              }
    332            }
    333          
    334            SB_TURN_OFF_LED1();
    335            SB_TURN_OFF_LED2();
    336          }
    337          
    338          /**************************************************************************************************
    339           * @fn          vddWait
    340           *
    341           * @brief       Loop waiting for 16 reads of the Vdd over the requested limit.
    342           *
    343           * input parameters
    344           *
    345           * @param       vdd - Vdd level to wait for.
    346           *
    347           * output parameters
    348           *
    349           * None.
    350           *
    351           * @return      None.
    352           **************************************************************************************************
    353           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    354          static void vddWait(uint8 vdd)
   \                     vddWait:
    355          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    356            uint8 cnt = 16;
   \   000000   7810         MOV     R0,#0x10
    357          
    358            do {
    359              do {
    360                ADCCON3 = 0x0F;
   \                     ??vddWait_0:
   \   000002   75B60F       MOV     0xb6,#0xf
    361                while (!(ADCCON1 & 0x80));
   \                     ??vddWait_1:
   \   000005   E5B4         MOV     A,0xb4
   \   000007   A2E7         MOV     C,0xE0 /* A   */.7
   \   000009   50FA         JNC     ??vddWait_1
    362              } while (ADCH < vdd);
   \   00000B   E5BB         MOV     A,0xbb
   \   00000D   C3           CLR     C
   \   00000E   99           SUBB    A,R1
   \   00000F   40F1         JC      ??vddWait_0
    363            } while (--cnt);
   \   000011   18           DEC     R0
   \   000012   E8           MOV     A,R0
   \   000013   70ED         JNZ     ??vddWait_0
    364          }
   \   000015   22           RET
   \   000016                REQUIRE ADCCON3
   \   000016                REQUIRE ADCCON1
   \   000016                REQUIRE ADCH

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_ffffffff:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_ffffffff>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_ffffffff>`:
   \   000000   FFFFFFFF     DD 4294967295

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_1:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_1>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_1>`:
   \   000000   01000000     DD 1

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_40000:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_40000>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_40000>`:
   \   000000   00000400     DD 262144
    365          
    366          /**************************************************************************************************
    367          */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      3      1   HalUARTPollISR
      1      9   HalUARTReadISR
      1      9   HalUARTWriteISR
      0      1   main
        0      1   -> HalUARTPollISR
        0      1   -> HalUARTReadISR
        0      1   -> sbExec
        0      1   -> sbImgValid
        0      1   -> sblInit
        0      1   -> sblJump
        0      1   -> vddWait
      2      1   sblInit
      0      1   sblJump
      0      1   vddWait


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Initializer for __Constant_1>
       4  ?<Initializer for __Constant_40000>
       4  ?<Initializer for __Constant_ffffffff>
       5  ?Subroutine0
      11  ?Subroutine1
      10  ?Subroutine2
      11  ?Subroutine3
       1  ADCCFG
       1  ADCCON1
       1  ADCCON3
       1  ADCH
       1  CLKCONCMD
       1  CLKCONSTA
       1  DMA0CFGH
       1  DMA0CFGL
      91  HalUARTPollISR
      76  HalUARTReadISR
     130  HalUARTWriteISR
       1  P0INP
       1  P0SEL
       1  P1DIR
       1  P2DIR
       1  PERCFG
       1  SLEEPCMD
       1  SLEEPSTA
       1  U0BAUD
       1  U0CSR
       1  U0DBUF
       1  U0GCR
       1  U0UCR
       1  WDCTL
       1  _A_IEN0
       1  _A_IRCON2
       1  _A_P0
       1  _A_P1
       1  _A_P2
       1  _A_TCON
       4  __Constant_1
       4  __Constant_40000
       4  __Constant_ffffffff
       8  dmaCh0
     517  isrCfg
     311  main
      57  sblInit
      29  sblJump
      22  vddWait

 
 753 bytes in segment NEAR_CODE
  27 bytes in segment SFR_AN
  12 bytes in segment XDATA_I
  12 bytes in segment XDATA_ID
 525 bytes in segment XDATA_Z
 
 753 bytes of CODE  memory (+ 12 bytes shared)
   0 bytes of DATA  memory (+ 27 bytes shared)
 525 bytes of XDATA memory (+ 12 bytes shared)

Errors: none
Warnings: none
